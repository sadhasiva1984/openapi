/*
 * Nudsf_DataRepository
 *
 * Nudsf Data Repository Service.   Â© 2022, 3GPP Organizational Partners (ARIB, ATIS, CCSA, ETSI, TSDSI, TTA, TTC).   All rights reserved.
 *
 * Source file: 3GPP TS 29.598 UDSF Services, V17.6.0.
 * Url: https://www.3gpp.org/ftp/Specs/archive/29_series/29.598/
 *
 * API version: 1.1.0
 * Generated by: OpenAPI Generator (https://openapi-generator.tech)
 */

package DataRepository

import (
	"github.com/sadhasiva1984/openapi"
	"github.com/sadhasiva1984/openapi/models"

	"context"
	"io/ioutil"
	"net/url"
	"strings"
)

// Linger please
var (
	_ context.Context
)

type RecordCRUDApiService service

/*
RecordCRUDApiService Bulk Deletion of Records
Delete multiple Records based on filter
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier of the Realm
 * @param StorageId - Identifier of the Storage
 * @param Filter -
 * @param SupportedFeatures - Features required to be supported by the target NF

@return BulkDeleteRecordsResponse
*/

// BulkDeleteRecordsRequest
type BulkDeleteRecordsRequest struct {
	RealmId           *string
	StorageId         *string
	Filter            *models.SearchExpression
	SupportedFeatures *string
}

func (r *BulkDeleteRecordsRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *BulkDeleteRecordsRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *BulkDeleteRecordsRequest) SetFilter(Filter models.SearchExpression) {
	r.Filter = &Filter
}
func (r *BulkDeleteRecordsRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type BulkDeleteRecordsResponse struct {
	RecordIdList models.RecordIdList
}

type BulkDeleteRecordsError struct {
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) BulkDeleteRecords(ctx context.Context, request *BulkDeleteRecordsRequest) (*BulkDeleteRecordsResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  BulkDeleteRecordsResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.Filter == nil {
		return nil, openapi.ReportError("Filter must be non nil")
	} else {
		localVarQueryParams.Add("filter", openapi.ParameterToString(request.Filter, "application/json"))
	}
	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}

	localVarHTTPContentTypes := []string{"application/json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.RecordIdList, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		return &localVarReturnValue, nil
	case 204:
		return &localVarReturnValue, nil
	case 400:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 406:
		return &localVarReturnValue, nil
	case 429:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v BulkDeleteRecordsError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

/*
RecordCRUDApiService Create/Modify Record
Create or Modify a Record with a user provided RecordId
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier(name) of the Realm
 * @param StorageId - Identifier of the Storage
 * @param RecordId - Identifier of the Record
 * @param Record - The record multipart request body. The meta part shall be the first part and is mandatory but can be empty and zero or more block parts may follow the meta part.
 * @param IfNoneMatch - Validator for conditional requests, as described in RFC 7232, 3.2
 * @param IfMatch - Record validator for conditional requests, as described in RFC 7232, 3.2
 * @param GetPrevious - Retrieve the Record before update
 * @param SupportedFeatures - Features required to be supported by the target NF

@return CreateOrModifyRecordResponse
*/

// CreateOrModifyRecordRequest
type CreateOrModifyRecordRequest struct {
	RealmId           *string
	StorageId         *string
	RecordId          *string
	Record            *models.Record
	IfNoneMatch       *string
	IfMatch           *string
	GetPrevious       *bool
	SupportedFeatures *string
}

func (r *CreateOrModifyRecordRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *CreateOrModifyRecordRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *CreateOrModifyRecordRequest) SetRecordId(RecordId string) {
	r.RecordId = &RecordId
}
func (r *CreateOrModifyRecordRequest) SetRecord(Record models.Record) {
	r.Record = &Record
}
func (r *CreateOrModifyRecordRequest) SetIfNoneMatch(IfNoneMatch string) {
	r.IfNoneMatch = &IfNoneMatch
}
func (r *CreateOrModifyRecordRequest) SetIfMatch(IfMatch string) {
	r.IfMatch = &IfMatch
}
func (r *CreateOrModifyRecordRequest) SetGetPrevious(GetPrevious bool) {
	r.GetPrevious = &GetPrevious
}
func (r *CreateOrModifyRecordRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type CreateOrModifyRecordResponse struct {
	CacheControl string
	ETag         string
	LastModified string
	Location     string
	Record       models.Record
}

type CreateOrModifyRecordError struct {
	CacheControl   string
	ETag           string
	LastModified   string
	RetryAfter     interface{}
	ProblemDetails models.ProblemDetails
	Record         models.Record
}

func (a *RecordCRUDApiService) CreateOrModifyRecord(ctx context.Context, request *CreateOrModifyRecordRequest) (*CreateOrModifyRecordResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Put")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateOrModifyRecordResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records/{recordId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recordId"+"}", openapi.StringOfValue(*request.RecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.GetPrevious != nil {
		localVarQueryParams.Add("get-previous", openapi.ParameterToString(request.GetPrevious, "multi"))
	}
	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}
	localVarHTTPContentTypes := []string{"multipart/mixed"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"multipart/mixed", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.IfNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = openapi.ParameterToString(request.IfNoneMatch, "csv")
	}

	if request.IfMatch != nil {
		localVarHeaderParams["If-Match"] = openapi.ParameterToString(request.IfMatch, "csv")
	}

	// body params
	localVarPostBody = request.Record

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.Record, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		localVarReturnValue.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		localVarReturnValue.ETag = localVarHTTPResponse.Header.Get("ETag")
		localVarReturnValue.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		return &localVarReturnValue, nil
	case 201:
		return &localVarReturnValue, nil
	case 204:
		return &localVarReturnValue, nil
	case 304:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.RetryAfter = localVarHTTPResponse.Header.Get("Retry-After")
		apiError.ErrorModel = v
		return nil, apiError
	case 400:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 408:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 412:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.Record, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		apiError.ErrorModel = v
		return nil, apiError
	case 413:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v CreateOrModifyRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

// CreateOrModifyRecordRecordExpiredPostRequest
type CreateOrModifyRecordRecordExpiredPostRequest struct {
	Record          *models.Record
	ContentLocation *string
}

func (r *CreateOrModifyRecordRecordExpiredPostRequest) SetRecord(Record models.Record) {
	r.Record = &Record
}
func (r *CreateOrModifyRecordRecordExpiredPostRequest) SetContentLocation(ContentLocation string) {
	r.ContentLocation = &ContentLocation
}

type CreateOrModifyRecordRecordExpiredPostResponse struct {
}

type CreateOrModifyRecordRecordExpiredPostError struct {
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) CreateOrModifyRecordRecordExpiredPost(ctx context.Context, uri string, request *CreateOrModifyRecordRecordExpiredPostRequest) (*CreateOrModifyRecordRecordExpiredPostResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("POST")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  CreateOrModifyRecordRecordExpiredPostResponse
	)

	// create path and map variables
	localVarPath := uri

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	localVarHTTPContentTypes := []string{"multipart/mixed"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.ContentLocation != nil {
		localVarHeaderParams["Content-Location"] = openapi.ParameterToString(request.ContentLocation, "csv")
	}

	// body params
	localVarPostBody = request.Record

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 204:
		return &localVarReturnValue, nil
	case 400:
		var v CreateOrModifyRecordRecordExpiredPostError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v CreateOrModifyRecordRecordExpiredPostError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v CreateOrModifyRecordRecordExpiredPostError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v CreateOrModifyRecordRecordExpiredPostError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v CreateOrModifyRecordRecordExpiredPostError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return &localVarReturnValue, nil
	}
}

/*
RecordCRUDApiService Delete a Record with an user provided RecordId
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier(name) of the Realm
 * @param StorageId - Identifier of the Storage
 * @param RecordId - Identifier of the Record
 * @param IfMatch - Record validator for conditional requests, as described in RFC 7232, 3.2
 * @param GetPrevious - Retrieve the Record before delete
 * @param SupportedFeatures - Features required to be supported by the target NF

@return DeleteRecordResponse
*/

// DeleteRecordRequest
type DeleteRecordRequest struct {
	RealmId           *string
	StorageId         *string
	RecordId          *string
	IfMatch           *string
	GetPrevious       *bool
	SupportedFeatures *string
}

func (r *DeleteRecordRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *DeleteRecordRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *DeleteRecordRequest) SetRecordId(RecordId string) {
	r.RecordId = &RecordId
}
func (r *DeleteRecordRequest) SetIfMatch(IfMatch string) {
	r.IfMatch = &IfMatch
}
func (r *DeleteRecordRequest) SetGetPrevious(GetPrevious bool) {
	r.GetPrevious = &GetPrevious
}
func (r *DeleteRecordRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type DeleteRecordResponse struct {
	ETag         string
	LastModified string
	Record       models.Record
}

type DeleteRecordError struct {
	CacheControl   string
	ETag           string
	LastModified   string
	RetryAfter     interface{}
	ProblemDetails models.ProblemDetails
	Record         models.Record
}

func (a *RecordCRUDApiService) DeleteRecord(ctx context.Context, request *DeleteRecordRequest) (*DeleteRecordResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Delete")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  DeleteRecordResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records/{recordId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recordId"+"}", openapi.StringOfValue(*request.RecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.GetPrevious != nil {
		localVarQueryParams.Add("get-previous", openapi.ParameterToString(request.GetPrevious, "multi"))
	}
	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}

	localVarHTTPContentTypes := []string{"application/json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"multipart/mixed", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.IfMatch != nil {
		localVarHeaderParams["If-Match"] = openapi.ParameterToString(request.IfMatch, "csv")
	}

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.Record, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		localVarReturnValue.ETag = localVarHTTPResponse.Header.Get("ETag")
		localVarReturnValue.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		return &localVarReturnValue, nil
	case 204:
		return &localVarReturnValue, nil
	case 304:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.RetryAfter = localVarHTTPResponse.Header.Get("Retry-After")
		apiError.ErrorModel = v
		return nil, apiError
	case 400:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 408:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 412:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.Record, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v DeleteRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

/*
RecordCRUDApiService Record's meta access
retrieve meta of a specific Record
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier of the Realm
 * @param StorageId - Identifier of the Storage
 * @param RecordId - Identifier of the Record
 * @param IfNoneMatch - Validator for conditional requests, as described in RFC 7232, 3.2
 * @param IfModifiedSince - Validator for conditional requests, as described in RFC 7232, 3.3
 * @param SupportedFeatures - Features required to be supported by the target NF

@return GetMetaResponse
*/

// GetMetaRequest
type GetMetaRequest struct {
	RealmId           *string
	StorageId         *string
	RecordId          *string
	IfNoneMatch       *string
	IfModifiedSince   *string
	SupportedFeatures *string
}

func (r *GetMetaRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *GetMetaRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *GetMetaRequest) SetRecordId(RecordId string) {
	r.RecordId = &RecordId
}
func (r *GetMetaRequest) SetIfNoneMatch(IfNoneMatch string) {
	r.IfNoneMatch = &IfNoneMatch
}
func (r *GetMetaRequest) SetIfModifiedSince(IfModifiedSince string) {
	r.IfModifiedSince = &IfModifiedSince
}
func (r *GetMetaRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type GetMetaResponse struct {
	CacheControl string
	ETag         string
	LastModified string
	RecordMeta   models.RecordMeta
}

type GetMetaError struct {
	CacheControl   string
	ETag           string
	RetryAfter     interface{}
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) GetMeta(ctx context.Context, request *GetMetaRequest) (*GetMetaResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetMetaResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records/{recordId}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recordId"+"}", openapi.StringOfValue(*request.RecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}

	localVarHTTPContentTypes := []string{"application/json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.IfNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = openapi.ParameterToString(request.IfNoneMatch, "csv")
	}

	if request.IfModifiedSince != nil {
		localVarHeaderParams["If-Modified-Since"] = openapi.ParameterToString(request.IfModifiedSince, "csv")
	}

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.RecordMeta, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		localVarReturnValue.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		localVarReturnValue.ETag = localVarHTTPResponse.Header.Get("ETag")
		localVarReturnValue.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		return &localVarReturnValue, nil
	case 304:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.RetryAfter = localVarHTTPResponse.Header.Get("Retry-After")
		apiError.ErrorModel = v
		return nil, apiError
	case 400:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v GetMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

/*
RecordCRUDApiService Record access
retrieve one specific Record
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier of the Realm
 * @param StorageId - Identifier of the Storage
 * @param RecordId - Identifier of the Record
 * @param IfNoneMatch - Validator for conditional requests, as described in RFC 7232, 3.2
 * @param IfModifiedSince - Validator for conditional requests, as described in RFC 7232, 3.3
 * @param SupportedFeatures - Features required to be supported by the target NF

@return GetRecordResponse
*/

// GetRecordRequest
type GetRecordRequest struct {
	RealmId           *string
	StorageId         *string
	RecordId          *string
	IfNoneMatch       *string
	IfModifiedSince   *string
	SupportedFeatures *string
}

func (r *GetRecordRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *GetRecordRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *GetRecordRequest) SetRecordId(RecordId string) {
	r.RecordId = &RecordId
}
func (r *GetRecordRequest) SetIfNoneMatch(IfNoneMatch string) {
	r.IfNoneMatch = &IfNoneMatch
}
func (r *GetRecordRequest) SetIfModifiedSince(IfModifiedSince string) {
	r.IfModifiedSince = &IfModifiedSince
}
func (r *GetRecordRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type GetRecordResponse struct {
	CacheControl string
	ETag         string
	LastModified string
	Record       models.Record
}

type GetRecordError struct {
	CacheControl   string
	ETag           string
	RetryAfter     interface{}
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) GetRecord(ctx context.Context, request *GetRecordRequest) (*GetRecordResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  GetRecordResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records/{recordId}"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recordId"+"}", openapi.StringOfValue(*request.RecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}

	localVarHTTPContentTypes := []string{"application/json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"multipart/mixed", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.IfNoneMatch != nil {
		localVarHeaderParams["If-None-Match"] = openapi.ParameterToString(request.IfNoneMatch, "csv")
	}

	if request.IfModifiedSince != nil {
		localVarHeaderParams["If-Modified-Since"] = openapi.ParameterToString(request.IfModifiedSince, "csv")
	}

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.Record, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		localVarReturnValue.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		localVarReturnValue.ETag = localVarHTTPResponse.Header.Get("ETag")
		localVarReturnValue.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		return &localVarReturnValue, nil
	case 304:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.RetryAfter = localVarHTTPResponse.Header.Get("Retry-After")
		apiError.ErrorModel = v
		return nil, apiError
	case 400:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v GetRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

/*
RecordCRUDApiService Records search with get
Retrieve one or multiple Records based on filter
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier of the Realm
 * @param StorageId - Identifier of the Storage
 * @param LimitRange - The most number of record references to fetch
 * @param Filter - Query filter using conditions on tags
 * @param CountIndicator - Indicates whether the number of records that matched the criteria shall be returned.
 * @param SupportedFeatures - Features required to be supported by the target NF
 * @param RetrieveRecords - Indicates whether the UDSF is requested to include matching records within the response.
 * @param MaxPayloadSize - Indicates the number of kilo octets the consumer is prepared to receive

@return SearchRecordResponse
*/

// SearchRecordRequest
type SearchRecordRequest struct {
	RealmId           *string
	StorageId         *string
	LimitRange        *int32
	Filter            *models.SearchExpression
	CountIndicator    *bool
	SupportedFeatures *string
	RetrieveRecords   *models.RetrieveRecords
	MaxPayloadSize    *int32
}

func (r *SearchRecordRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *SearchRecordRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *SearchRecordRequest) SetLimitRange(LimitRange int32) {
	r.LimitRange = &LimitRange
}
func (r *SearchRecordRequest) SetFilter(Filter models.SearchExpression) {
	r.Filter = &Filter
}
func (r *SearchRecordRequest) SetCountIndicator(CountIndicator bool) {
	r.CountIndicator = &CountIndicator
}
func (r *SearchRecordRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}
func (r *SearchRecordRequest) SetRetrieveRecords(RetrieveRecords models.RetrieveRecords) {
	r.RetrieveRecords = &RetrieveRecords
}
func (r *SearchRecordRequest) SetMaxPayloadSize(MaxPayloadSize int32) {
	r.MaxPayloadSize = &MaxPayloadSize
}

type SearchRecordResponse struct {
	RecordSearchResult models.RecordSearchResult
}

type SearchRecordError struct {
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) SearchRecord(ctx context.Context, request *SearchRecordRequest) (*SearchRecordResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Get")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  SearchRecordResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.LimitRange != nil {
		localVarQueryParams.Add("limit-range", openapi.ParameterToString(request.LimitRange, "multi"))
	}
	if request.Filter != nil {
		localVarQueryParams.Add("filter", openapi.ParameterToString(request.Filter, "application/json"))
	}
	if request.CountIndicator != nil {
		localVarQueryParams.Add("count-indicator", openapi.ParameterToString(request.CountIndicator, "multi"))
	}
	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}
	if request.RetrieveRecords != nil {
		localVarQueryParams.Add("retrieve-records", openapi.ParameterToString(request.RetrieveRecords, "multi"))
	}
	if request.MaxPayloadSize != nil {
		localVarQueryParams.Add("max-payload-size", openapi.ParameterToString(request.MaxPayloadSize, "multi"))
	}

	localVarHTTPContentTypes := []string{"application/json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.RecordSearchResult, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		return &localVarReturnValue, nil
	case 204:
		return &localVarReturnValue, nil
	case 400:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 406:
		return &localVarReturnValue, nil
	case 429:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v SearchRecordError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}

/*
RecordCRUDApiService Record's meta update
update meta of a specific Record
 * @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 * @param RealmId - Identifier of the Realm
 * @param StorageId - Identifier of the Storage
 * @param RecordId - Identifier of the Record
 * @param PatchItem - Meta data to patch
 * @param IfMatch - Record validator for conditional requests, as described in RFC 7232, 3.2
 * @param SupportedFeatures - Features required to be supported by the target NF

@return UpdateMetaResponse
*/

// UpdateMetaRequest
type UpdateMetaRequest struct {
	RealmId           *string
	StorageId         *string
	RecordId          *string
	PatchItem         []models.PatchItem
	IfMatch           *string
	SupportedFeatures *string
}

func (r *UpdateMetaRequest) SetRealmId(RealmId string) {
	r.RealmId = &RealmId
}
func (r *UpdateMetaRequest) SetStorageId(StorageId string) {
	r.StorageId = &StorageId
}
func (r *UpdateMetaRequest) SetRecordId(RecordId string) {
	r.RecordId = &RecordId
}
func (r *UpdateMetaRequest) SetPatchItem(PatchItem []models.PatchItem) {
	r.PatchItem = PatchItem
}
func (r *UpdateMetaRequest) SetIfMatch(IfMatch string) {
	r.IfMatch = &IfMatch
}
func (r *UpdateMetaRequest) SetSupportedFeatures(SupportedFeatures string) {
	r.SupportedFeatures = &SupportedFeatures
}

type UpdateMetaResponse struct {
	CacheControl string
	ETag         string
	LastModified string
	PatchResult  models.PatchResult
}

type UpdateMetaError struct {
	CacheControl   string
	ETag           string
	RetryAfter     interface{}
	ProblemDetails models.ProblemDetails
}

func (a *RecordCRUDApiService) UpdateMeta(ctx context.Context, request *UpdateMetaRequest) (*UpdateMetaResponse, error) {
	var (
		localVarHTTPMethod   = strings.ToUpper("Patch")
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  UpdateMetaResponse
	)

	// create path and map variables
	localVarPath := a.client.cfg.BasePath() + "/{realmId}/{storageId}/records/{recordId}/meta"
	localVarPath = strings.Replace(localVarPath, "{"+"realmId"+"}", openapi.StringOfValue(*request.RealmId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"storageId"+"}", openapi.StringOfValue(*request.StorageId), -1)
	localVarPath = strings.Replace(localVarPath, "{"+"recordId"+"}", openapi.StringOfValue(*request.RecordId), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if request.SupportedFeatures != nil {
		localVarQueryParams.Add("supported-features", openapi.ParameterToString(request.SupportedFeatures, "multi"))
	}
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	localVarHeaderParams["Content-Type"] = localVarHTTPContentTypes[0] // use the first content type specified in 'consumes'

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json", "application/problem+json"}

	// set Accept header
	localVarHTTPHeaderAccept := strings.Join(localVarHTTPHeaderAccepts, ", ")
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}

	if request.IfMatch != nil {
		localVarHeaderParams["If-Match"] = openapi.ParameterToString(request.IfMatch, "csv")
	}

	// body params
	localVarPostBody = request.PatchItem

	r, err := openapi.PrepareRequest(ctx, a.client.cfg, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return nil, err
	}

	localVarHTTPResponse, err := openapi.CallAPI(a.client.cfg, r)
	if err != nil || localVarHTTPResponse == nil {
		return nil, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	if err != nil {
		return nil, err
	}
	err = localVarHTTPResponse.Body.Close()
	if err != nil {
		return nil, err
	}

	apiError := openapi.GenericOpenAPIError{
		RawBody:     localVarBody,
		ErrorStatus: localVarHTTPResponse.StatusCode,
	}

	switch localVarHTTPResponse.StatusCode {
	case 200:
		err = openapi.Deserialize(&localVarReturnValue.PatchResult, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		localVarReturnValue.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		localVarReturnValue.ETag = localVarHTTPResponse.Header.Get("ETag")
		localVarReturnValue.LastModified = localVarHTTPResponse.Header.Get("Last-Modified")
		return &localVarReturnValue, nil
	case 204:
		return &localVarReturnValue, nil
	case 304:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		v.CacheControl = localVarHTTPResponse.Header.Get("Cache-Control")
		v.ETag = localVarHTTPResponse.Header.Get("ETag")
		v.RetryAfter = localVarHTTPResponse.Header.Get("Retry-After")
		apiError.ErrorModel = v
		return nil, apiError
	case 400:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 401:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 403:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 404:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 408:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 500:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	case 503:
		var v UpdateMetaError
		err = openapi.Deserialize(&v.ProblemDetails, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
		if err != nil {
			return nil, err
		}
		apiError.ErrorModel = v
		return nil, apiError
	default:
		return nil, apiError
	}
}
